type ProjectCreationEvent @entity {
  "The txn hash of this event"
  id: ID!

  owner: Bytes!

  "Address of the issuer contract generated"
  issuer: Bytes!

  "Address of the gentk contract generated"
  gentk: Bytes!

  "The timestamp of the block the event is in"
  timestamp: BigInt!

  "The block level of the transaction"
  level: BigInt!
}

type TokenMetadataAssignedEvent @entity {
  "The txn hash of this event"
  id: ID!

  "URL of the off chain storage storing the token metadata"
  offChainMetadata: [OffChainTokenMetadata!]!

  "List of attributes describing the token"
  onChainMetadata: [OnChainTokenMetadata!]!

  "The timestamp of the block the event is in"
  timestamp: BigInt!

  "The block level of the transaction"
  level: BigInt!
}

type OnChainTokenMetadata @entity {
  "The id of the token <contract:tokenId>"
  id: ID!

  "List of attributes describing the token"
  metadata: Bytes!
}

type OffChainTokenMetadata @entity {
  "The id of the token <contract:tokenId>"
  id: ID!

  "List of attributes describing the token"
  metadata: String!
}

type TokenTransferEvent @entity {
  "The txn hash of this event"
  id: ID!

  "Address of the ender of the NFT"
  from: Bytes!

  "Address of the receiver of the NFT"
  to: Bytes!

  "Address of the contract of the NFT"
  contract: Bytes!

  "Token ID of the transferred NFT"
  tokenId: BigInt!

  "The timestamp of the block the event is in"
  timestamp: BigInt!

  "The block level of the transaction"
  level: BigInt!
}

type IssuerMintedEvent @entity {
  "The txn hash of this event"
  id: ID!

  "Address of the issuer contract"
  address: Bytes!

  "Codex data for the issuer"
  codexData: Codex!

  "Metadata of the issuer contract"
  metadata: Bytes!

  "Size of the input for the Fx Params"
  inputBytesSize: BigInt!

  "Amount of token that will be mintable through the issuer"
  amount: BigInt!

  "Optional closing time if the issuer is using Open Editions"
  openEditionsClosingTime: BigInt

  "Gracing period for the mint tickets if they are used by the issuer"
  mintTicketGracingPeriod: BigInt

  "List of the issuer reserves"
  reserves: [Reserve!]!

  "Pricing method and configuration used by the issuer"
  pricing: Pricing!

  "Primary split of the issuer, used for the minting"
  primarySplit: Split!

  "Royalties split of the issuer, used for the secondary market"
  royaltiesSplit: Split!

  "Flag setting if the issuer is currently enabled"
  enabled: Boolean!

  "List of the issuer tags"
  tags: [BigInt!]!

  "List of the issuer on chain scripts, only for fully on chain tokens"
  onChainScripts: [OnChainScript!]

  "The timestamp of the block the event is in"
  timestamp: BigInt!

  "The block level of the transaction"
  level: BigInt!
}

type Codex @entity {
  "The id of the codex, equal to the issuer mint event id"
  id: ID!

  "Type of the input: either off or on chain"
  inputType: BigInt!

  "Encoded value for the codex"
  value: Bytes!

  "Id of the codex entry"
  codexId: BigInt!
}

type Reserve @entity {
  "The id of the reserve, equal to the issuer event id and method id concatenated: <issuer:methodId>"
  id: ID!

  "Idenfitier of the reserve method"
  methodId: BigInt!

  "Amount of tokens allocated to this reserve"
  amount: BigInt!

  "Encoded data for the reserve"
  data: Bytes!
}

type Pricing @entity {
  "The id of the pricing, equal to the issuer mint event id"
  id: ID!

  "Idenfitier of the pricing method"
  pricingId: BigInt!

  "Encoded data for the pricing configuration"
  details: Bytes!

  "Flag for When there is only one token remaining after deducting the reserves from the balance, the contract locks the current price - only for dutch auction"
  lockForReserves: Boolean!
}

type Split @entity {
  "The id of the royalty, equal to the issuer mint event id, prefixed with 'P-' if it is primary, and 'S-' if it is secondary"
  id: ID!

  "Recipient of the royalties"
  recipient: Bytes!

  "Share of the royalties"
  value: BigInt!
}

type OnChainScript @entity {
  "The id of the script, equal to its name"
  id: ID!

  "Address of the contract storing the script code"
  storageContractAddress: Bytes!

  "Data provided to the storage contract"
  contractData: Bytes!

  "Wrapping type of the script in the storage: Base64, Inlined, GZIPPED, etc"
  wrapType: Int!

  "Optional wrap prefix"
  wrapPrefix: Bytes

  "Optional wrap suffix"
  wrapSuffix: Bytes

  "Optional script content"
  scriptContent: Bytes
}

type IssuerBurnedEvent @entity {
  "The id of the script, equal to its name"
  id: ID!

  issuer: Bytes!

  "The timestamp of the block the event is in"
  timestamp: BigInt!

  "The block level of the transaction"
  level: BigInt!
}
